[{"id":0,"href":"/showcase/docs/shortcodes/integrantes/","title":"Integrantes","section":"Shortcodes","content":"Integrantes #  Emmanuel Steven Rojas Arcila #   Perfil #  Estudiante de Sistemas y Computación cursando noveno semestre en la Universidad nacional de Colombia. Con intereses en las ramas de la criptografía y desarrollo de software con enfoques en el sector del frontend. Entre sus intereses fuera del área académica se encuentran realizar ejercicio y ver películas.   Santiago Vargas Avendaño #   Perfil #  Es un estudiante de ingeniería de sistemas y computación en noveno semestre, entre sus principales intereses académicos están la rama del desarrollo e ingeniería de software con especial enfoque en el backend. Los principales pasatiempos son el Voleibol, las manualidades (origami, tejido, bordado) y las series de televisión.   "},{"id":1,"href":"/showcase/docs/shortcodes/referencias/","title":"Referencias","section":"Shortcodes","content":"Referencias #  Primer taller #   Ilusión de la pirámide - Michael Bach Ilusión dinámica de Ebbinghaus - Michael Bach Efecto estereoquinético - Michael Bach Inhibición lateral Profundidad estereoquinética Ebbinghaus  Segundo taller #   Aliasing \u0026amp; Anti-aliasing Computer Graphics Antialiasing Aliasing Rasterization: a Practical Implementation   "},{"id":2,"href":"/showcase/docs/shortcodes/registros/","title":"Registros","section":"Shortcodes","content":"Registros #  En está página se mantienen el registro de los encuentros\nPrimer taller #  29/marzo/2022 Primera entrega de propuesta hacia el profesor de 3 ilusiones visuales:\n Ilusión de la piramide Ilusión dinámica de Ebbinghaus Efecto estereoquinético también se planteó la idea de entregar un programa de \u0026ldquo;Todo es Om\u0026rdquo; pero por motivos de alcance de la entrega se concluyó que no era ideal.    31/marzo/2022 En esta sesión se presentó al profesor la ilusión dinámica de Ebbinghaus y la ilusión de la piramide, a lo cual se recibieron sus respectivas recomendaciones y sugerencias por parte del profesor, durante la clase se trabajó para poder determinar bien las coordenadas en las ilusiones.   Segundo taller #  03/mayo/2022 Esta fue la primera sesión para la realización del taller, en esta revisamos cuales eran los posibles ejercicios a realizar para esta segunda entrega y que herramientas teniamos que utilizar para llevarlos a cabo.   06/mayo/2022 Esta sesión fue la primera aproximación que tuvimos con la libreria de Quadrille, revisamos toda la documentación necesaria y se habló con el profesor sobre el ejercicio que se iba a realizar, de esta charla se encontró que a partir del metodo de RasterizeTriangle ibamos a poder hacer la implementación de Anti-aliasing.   10/mayo/2022 En esta sesión se hizo la instalación y el uso del mousePad que el profesor llevó a la clase para poder entender como funcionaba este y poder averiguar si podria ser o no implementado con el proyecto, dado el tiempo que se requería y el no contar con el de manera permanente se decidió hacer uso de la tableta gráfica.   12/mayo/2022 Durante esta sesión fue el avance teórico sobre como se va a realizar el Anti-aliasing y fue brindado por el profesor una guía sobre como podiamos hacer la implementación.   17/mayo/2022 En esta sesión dado que no se realizó sesión sincrónica de la clase en la universidad no se presentó ningun avance con el prodesor, sin embargo, el espacio de la clase fue aprovechado para hacer la primera aproximación de la tableta gráfica con el entorno de p5.   19/mayo/2022 Sesión final antes de la presentación durante la cual se mostró al profesor lo realizado por el Anti-aliasing y el sugirió añadir un sombreado al mismo, lo cual se implementó en la misma clase.   "},{"id":3,"href":"/showcase/docs/shortcodes/Taller-1/","title":"Taller 1","section":"Shortcodes","content":"Taller 1 #  Esto fue el trabajo realizado para la primera entrega de computación visual.\n"},{"id":4,"href":"/showcase/docs/shortcodes/Taller-1/ebbinghaus/","title":"Ebbinghaus","section":"Taller 1","content":"Ilusión dinámica de Ebbinghaus #  Planteamiento del problema #  Dentro del sitio web de Michael Bach se encontró una ilusión óptica que es la versión dinámica de \u0026ldquo;La ilusión de Ebbinghaus\u0026rdquo;. La ilusión consta de un anillo de discos azules y en su centro un disco naranja y todo se mueve, los discos azules cambian de tamaño pero el disco naranja permanece siempre con un tamaño constante, sin embargo, cuando los discos azules alcanzan el mayor tamaño el disco naranja parece haber disminuido de tamaño y de igual manera cuando los discos azules alcanzan su menor tamaño el disco naranja parece haber aumentado su tamaño.\nAntecedentes #  Esta ilusión corresponde a una variación dinámica de la ilusión de Ebbinghaus, variación creada por Christopher D. Blair, Gideon P. Caplovitz y Ryan E.B. Mruczek, que logró potenciar la fuerza de la ilusión y fue ganadora en el \u0026ldquo;Visual Illusion Contest\u0026rdquo; de 2014. En la ilusión de Ebbinghaus, se ven dos anillos de discos azules uno con los discos grandes y otro con los discos pequeños, en el centro de ambos anillos hay dos discos naranjas que a pesar de que no lo parezcan tienen igual tamaño; la ilusión lleva el nombre de Hermann Ebbinghaus, un pionero en la investigación de la memoria, que probablemente descubrió esta ilusión en la década de 1890, pero no la divulgó en ninguna publicación específica. Más adelante, Titchener (sin reclamar su autoría) la publicó en un libro de texto de 1901; por ello, también se le suele conocer como la ilusión de Titchener.\nCódigo (solución) y resultados #  Código en p5.js let x = 400,y = 400, L = 22, A, H, rad, distance, aux = 1;  function setup() {  createCanvas(500, 500);  frameRate(40);   A = cos(PI/3)*L;  H = sin(PI/3)*L; }  function draw() {  background(191);  if((frameCount-1) % 125 == 0){  aux = -aux;  }  x = x + aux * 1.25;  y = y + aux * 1.25;  noStroke();  fill(235, 131, 26);  ellipse(x,y,30);  fill(80, 125, 230);   rad = 12*pow((400/x),5);  distance = pow((400/x),4)   ellipse(x-L*distance,y,rad);  ellipse(x+L*distance,y,rad);   ellipse(x+A*distance,y-H*distance,rad);  ellipse(x-A*distance,y-H*distance,rad);   ellipse(x+A*distance,y+H*distance,rad);  ellipse(x-A*distance,y+H*distance,rad);   strokeWeight(5);  stroke(230, 216, 32);  point(x,y);  stroke(0, 60, 138);  point(x-A*distance,y-H*distance); }         let x = 400,y = 400, L = 22, A, H, rad, distance, aux = 1; function setup() { createCanvas(500, 500); frameRate(40); A = cos(PI/3)*L; H = sin(PI/3)*L; } function draw() { background(191); if((frameCount-1) % 125 == 0){ aux = -aux; } x = x \u0026#43; aux * 1.25; y = y \u0026#43; aux * 1.25; noStroke(); fill(235, 131, 26); ellipse(x,y,30); fill(80, 125, 230); rad = 12*pow((400/x),5); distance = pow((400/x),4) ellipse(x-L*distance,y,rad); ellipse(x\u0026#43;L*distance,y,rad); ellipse(x\u0026#43;A*distance,y-H*distance,rad); ellipse(x-A*distance,y-H*distance,rad); ellipse(x\u0026#43;A*distance,y\u0026#43;H*distance,rad); ellipse(x-A*distance,y\u0026#43;H*distance,rad); strokeWeight(5); stroke(230, 216, 32); point(x,y); stroke(0, 60, 138); point(x-A*distance,y-H*distance); }      \"  Conclusiones y trabajo futuro #  Basados en los resultados y en un proceso de observación, se concluye que existe una tendencia a aumentar el fenómeno visual generado cuando la visión del observador se fija en la circunferencia interior plasmada dentro del disco azul superior izquierdo. La ilusión de Ebbinghaus ha desempeñado un papel crucial en el debate sobre la existencia de vías separadas en el cerebro para la visión de percepción y visión de la acción. Se ha argumentado que la ilusión de Ebbinghaus distorsiona la percepción del tamaño, pero no para la acción. Así mismo se encontró un estudio en el cual muestran que existen 70 variantes genéticas relacionadas con la percepción de la ilusión de Ebbinghaus. Uno de los distintos campos en los que se puede seguir trabajando con la ilusión de Ebbinghaus es con la percepción de colores y si estos afectan de alguna manera la percepción del tamaño, también se puede considerar analizar si la forma en la que se está moviendo el sistema afecta que tanto se percibe la ilusión.\n"},{"id":5,"href":"/showcase/docs/shortcodes/Taller-1/estereoquinetico/","title":"Estereoquinetico","section":"Taller 1","content":"Efecto estereoquinético #  Planteamiento del problema #  En la profundidad estereo cinética, el movimiento de rotación aumenta la impresión de profundidad que se observa en los patrones de anillos concéntricos. Normalmente, la rotación crea una impresión vívida de un cono que sobresale o un túnel que retrocede, o ambos.\nAntecedentes #  La primera vez que el término de profundidad estereoquinética fue descrito, fue en 1924 por Musatti CL en un informe científico (Sui fenomeni stereocineti) sobre la ilusión estereoquinética, atribuyendo el descubrimiento y el nombre a su maestro Vittorio Benussi. Este también fue usado cerca del año 1935 por el artista Marcel Duchamp, que llamaba \u0026ldquo;rotorrelieves\u0026rdquo; a sus discos giratorios.\nCódigo (solución) y resultados #  Código en p5.js let movement = 0, stop = 1, crater = 1; function setup() {  createCanvas(500, 500);  background(255);  frameRate(30);  noStroke();   buttonStop = createButton(\u0026#39;Parar\u0026#39;);  buttonStop.position(0, 478);  buttonStop.mousePressed(stop_move);   buttonReset = createButton(\u0026#39;Resetear\u0026#39;);  buttonReset.position(430, 0);  buttonReset.mousePressed(reset);   buttonInvert = createButton(\u0026#39;Crater\u0026#39;);  buttonInvert.position(447, 478);  buttonInvert.mousePressed(invert);  buttonInvert.style(\u0026#39;background-color\u0026#39;, color(255)); }  function invert() {  crater *= -1;  if(crater \u0026gt; 0){  buttonInvert.style(\u0026#39;background-color\u0026#39;, color(255));  }else{  buttonInvert.style(\u0026#39;background-color\u0026#39;, color(125));  } }  function reset() {  movement = 0;  stop = 1;  crater = 1;  buttonInvert.style(\u0026#39;background-color\u0026#39;, color(255)); }  function stop_move() {  stop *= -1; }  function draw() {  let aux = 2;  fill(0,0,255);  ellipse(250,250,500);  for (let i = 1; i \u0026lt; 12; i++) {  if(i % 2 == 0){  fill(0,0,255);  }else{  fill(255,255,0);  }  if(crater==1){  ellipse(250+(cos((movement % 360)*PI/180)*i*20),250+(sin((movement % 360)*PI/180)*i*20),500-i*40);  }else{  if(i \u0026lt; 7){  ellipse(250+(cos((movement % 360)*PI/180)*i*20),250+(sin((movement % 360)*PI/180)*i*20),500-i*40);  aux = i - 1;  }else{  ellipse(250+(cos((movement % 360)*PI/180)*aux*20),250+(sin((movement % 360)*PI/180)*aux*20),500-i*40);  aux -= 1;  }  }  }  if(stop == 1){  movement += 1;  }  }         let movement = 0, stop = 1, crater = 1; function setup() { createCanvas(500, 500); background(255); frameRate(30); noStroke(); buttonStop = createButton(\u0026#39;Parar\u0026#39;); buttonStop.position(0, 478); buttonStop.mousePressed(stop_move); buttonReset = createButton(\u0026#39;Resetear\u0026#39;); buttonReset.position(430, 0); buttonReset.mousePressed(reset); buttonInvert = createButton(\u0026#39;Crater\u0026#39;); buttonInvert.position(447, 478); buttonInvert.mousePressed(invert); buttonInvert.style(\u0026#39;background-color\u0026#39;, color(255)); } function invert() { crater *= -1; if(crater \u0026gt; 0){ buttonInvert.style(\u0026#39;background-color\u0026#39;, color(255)); }else{ buttonInvert.style(\u0026#39;background-color\u0026#39;, color(125)); } } function reset() { movement = 0; stop = 1; crater = 1; buttonInvert.style(\u0026#39;background-color\u0026#39;, color(255)); } function stop_move() { stop *= -1; } function draw() { let aux = 2; fill(0,0,255); ellipse(250,250,500); for (let i = 1; i \u0026lt; 12; i\u0026#43;\u0026#43;) { if(i % 2 == 0){ fill(0,0,255); }else{ fill(255,255,0); } if(crater==1){ ellipse(250\u0026#43;(cos((movement % 360)*PI/180)*i*20),250\u0026#43;(sin((movement % 360)*PI/180)*i*20),500-i*40); }else{ if(i \u0026lt; 7){ ellipse(250\u0026#43;(cos((movement % 360)*PI/180)*i*20),250\u0026#43;(sin((movement % 360)*PI/180)*i*20),500-i*40); aux = i - 1; }else{ ellipse(250\u0026#43;(cos((movement % 360)*PI/180)*aux*20),250\u0026#43;(sin((movement % 360)*PI/180)*aux*20),500-i*40); aux -= 1; } } } if(stop == 1){ movement \u0026#43;= 1; } }      \"  Manejo de la ilusión #  En la parte superior derecha se encuentra un botón de \u0026ldquo;Resetear\u0026rdquo; el cual devuelve la ilusión a su estado original que es sin cráter y la posición inicial; en la esquina inferior izquierda se encuentra el botón de \u0026ldquo;Parar\u0026rdquo; con el cual la ilusión interrumpe su rotación hasta que este sea pulsado de nuevo; por último en la esquina inferior derecha se encuentra un boton de \u0026ldquo;cráter\u0026rdquo; el cual sirve para generar dentro de la ilusión un efecto de profundidad.\nConclusiones y trabajo futuro #  Tomando en cuenta los resultados de la codificación y las pruebas visuales del mismo, se puede evidenciar cómo el movimiento de rotación en los círculos genera la impresión de profundidad. Como implementaciones a desarrollar para próximos intentos, se sugiere la idea de estudiar la combinación otro tipo de figuras y cómo eso cambia la dinámica de rotación, adicionalmente se sugiere que se tengan en cuenta los componente principales de la ilusión, tanto la rotación como la rapidez con la que se realiza, y sus relaciones o capacidades de potenciar las ilusiones propuestas.\n"},{"id":6,"href":"/showcase/docs/shortcodes/Taller-1/piramide/","title":"Piramide","section":"Taller 1","content":"Ilusión de la pirámide #  Planteamiento del problema #  Se encontró dentro del archivo web del investigador Michael Bach sobre fenómenos visuales, una ilusión óptica denominada “ilusión de la pirámide” efecto perceptivo relacionado con todos los fenómenos que implican inhibición lateral.\nLa inhibición lateral se define como el proceso por el cual una célula inhibe la actividad de las células adyacentes. En las células de la retina, la inhibición lateral genera un realce de los bordes y un mayor contraste en las imágenes que se forman en el cerebro. El efecto de ésta inhibición lateral fue descubierto por Ernst Mach, que explicó en 1865 la ilusión visual denominada bandas de March. Este efecto produce que paneles que generan diferentes sombras colocados uno al lado del otro aparezcan más claros o más oscuros en las transiciones, a pesar del color uniforme dentro de un panel. Los paneles aparecen más claros en el borde con un panel más oscuro, y más oscuros en el borde con un panel más claro.\nEl propósito de la ilusión yace en generar la sensación de la existencia de una “X” dentro de cuadrados concéntricos en sus esquinas cuando realmente no existe. Para esto, se implementó un código que generase cuadrados concéntricos uno encima de otro, en el cual se va degradando ligeramente el color del cuadro siguiente, con lo cual, conforme mayor sea la cantidad de cuadros generados, la ilusión óptica empieza a hacer su aparición.\nAntecedentes #  Se tiene conocimiento de que fue demostrado por primera vez por Martinez-Conde \u0026amp; Macknik en la Reunión Soc Neurosci de 2001. Se ha incorporado a muchas pinturas Op Art como Arcturus II de Victor Vasarely.\nCódigo (solución) y resultados #  Código en p5.js let maxSixe = 500, h, maxMumberSquares = 50, squares = 1, color_val = \u0026#34;Azul\u0026#34;, invert_flag = 1; function setup() {  createCanvas(maxSixe+100, maxSixe);  background(255);  noStroke();  frameRate(20);   buttonUp = createButton(\u0026#39;⯅\u0026#39;);  buttonUp.position(560, 200);  buttonUp.mousePressed(changeUp);   buttonDown = createButton(\u0026#39;⯆\u0026#39;);  buttonDown.position(560, 220);  buttonDown.mousePressed(changeDown);   buttonReset = createButton(\u0026#39;Resetear\u0026#39;);  buttonReset.position(525, 100);  buttonReset.mousePressed(reset);   buttonInvert = createButton(\u0026#39;Invertir\u0026#39;);  buttonInvert.position(530, 400);  buttonInvert.mousePressed(invert);  buttonInvert.style(\u0026#39;background-color\u0026#39;, color(255));   color_sel = createSelect();  color_sel.position(530, 300);  color_sel.option(\u0026#39;Azul\u0026#39;);  color_sel.option(\u0026#39;Verde\u0026#39;);  color_sel.option(\u0026#39;Rojo\u0026#39;);  color_sel.selected(\u0026#39;Azul\u0026#39;);  color_sel.changed(mySelectEvent); }  function invert() {  invert_flag *= -1;  if(invert_flag \u0026gt; 0){  buttonInvert.style(\u0026#39;background-color\u0026#39;, color(255));  }else{  buttonInvert.style(\u0026#39;background-color\u0026#39;, color(125));  } }  function reset() {  squares = 1;  color_val = \u0026#34;Azul\u0026#34;;  color_sel.selected(\u0026#39;Azul\u0026#39;); }  function mySelectEvent() {  color_val = color_sel.value(); }  function changeUp() {  if(squares+1 \u0026lt; maxMumberSquares){  squares += 1;  } }  function changeDown() {  if(squares-1\u0026gt;0){  squares -= 1;  } }  function draw() {  fill(255);  rect(530,200,20,45)  textSize(15);  fill(0);  text(squares, 530,210,20,60);   if(squares \u0026lt; maxMumberSquares){  h = maxSixe/(2*squares);  for(let i = 0; i \u0026lt; squares; i++){  if(invert_flag \u0026gt; 0){  if(color_val == \u0026#34;Rojo\u0026#34;){  fill(255,0+i*(255/squares),0+i*(255/squares));  }else if(color_val == \u0026#34;Verde\u0026#34;){  fill(0+i*(255/squares),255,0+i*(255/squares));  }else{  fill(0+i*(255/squares),0+i*(255/squares),255);  }  }else{  if(color_val == \u0026#34;Rojo\u0026#34;){  fill(255-i*(255/squares),0,0);  }else if(color_val == \u0026#34;Verde\u0026#34;){  fill(0,255-i*(255/squares),0);  }else{  fill(0,0,255-i*(255/squares));  }  }  rect(0+i*h,0+i*h, 500-i*2*h);  }  } }         let maxSixe = 500, h, maxMumberSquares = 50, squares = 1, color_val = \u0026#34;Azul\u0026#34;, invert_flag = 1; function setup() { createCanvas(maxSixe\u0026#43;100, maxSixe); background(255); noStroke(); frameRate(20); buttonUp = createButton(\u0026#39;⯅\u0026#39;); buttonUp.position(560, 200); buttonUp.mousePressed(changeUp); buttonDown = createButton(\u0026#39;⯆\u0026#39;); buttonDown.position(560, 220); buttonDown.mousePressed(changeDown); buttonReset = createButton(\u0026#39;Resetear\u0026#39;); buttonReset.position(525, 100); buttonReset.mousePressed(reset); buttonInvert = createButton(\u0026#39;Invertir\u0026#39;); buttonInvert.position(530, 400); buttonInvert.mousePressed(invert); buttonInvert.style(\u0026#39;background-color\u0026#39;, color(255)); color_sel = createSelect(); color_sel.position(530, 300); color_sel.option(\u0026#39;Azul\u0026#39;); color_sel.option(\u0026#39;Verde\u0026#39;); color_sel.option(\u0026#39;Rojo\u0026#39;); color_sel.selected(\u0026#39;Azul\u0026#39;); color_sel.changed(mySelectEvent); } function invert() { invert_flag *= -1; if(invert_flag \u0026gt; 0){ buttonInvert.style(\u0026#39;background-color\u0026#39;, color(255)); }else{ buttonInvert.style(\u0026#39;background-color\u0026#39;, color(125)); } } function reset() { squares = 1; color_val = \u0026#34;Azul\u0026#34;; color_sel.selected(\u0026#39;Azul\u0026#39;); } function mySelectEvent() { color_val = color_sel.value(); } function changeUp() { if(squares\u0026#43;1 \u0026lt; maxMumberSquares){ squares \u0026#43;= 1; } } function changeDown() { if(squares-1\u0026gt;0){ squares -= 1; } } function draw() { fill(255); rect(530,200,20,45) textSize(15); fill(0); text(squares, 530,210,20,60); if(squares \u0026lt; maxMumberSquares){ h = maxSixe/(2*squares); for(let i = 0; i \u0026lt; squares; i\u0026#43;\u0026#43;){ if(invert_flag \u0026gt; 0){ if(color_val == \u0026#34;Rojo\u0026#34;){ fill(255,0\u0026#43;i*(255/squares),0\u0026#43;i*(255/squares)); }else if(color_val == \u0026#34;Verde\u0026#34;){ fill(0\u0026#43;i*(255/squares),255,0\u0026#43;i*(255/squares)); }else{ fill(0\u0026#43;i*(255/squares),0\u0026#43;i*(255/squares),255); } }else{ if(color_val == \u0026#34;Rojo\u0026#34;){ fill(255-i*(255/squares),0,0); }else if(color_val == \u0026#34;Verde\u0026#34;){ fill(0,255-i*(255/squares),0); }else{ fill(0,0,255-i*(255/squares)); } } rect(0\u0026#43;i*h,0\u0026#43;i*h, 500-i*2*h); } } }      \"  Manejo de la ilusión #  En la parte derecha de la ilusión se encuentran los controles para manejarla, el primero es un botón de \u0026ldquo;Resetearla\u0026rdquo; que lleva la ilusión a sus valores por defecto que es 1 cuadro y el color azul; seguido encontramos dos botones junto con un número a su lado el botón con la flecha hacia arriba aumenta la cantidad de cuadrados (hasta 50), el botón con la flecha hacia abajo disminuye la cantidad de cuadrados (hasta 1) y el número al lado de ellos muestra la cantidad actual de cuadrados; luego hayamos un menú desplegable en el cual podemos escoger cualquiera de los tres colores con los cuales se presenta la ilusión de la pirámide y por ultimo se encuentra un botón para “Invertir” la ilusión, es decir, que el degrade desde el color principal sea hacia blanco o hacia negro.\nConclusiones y trabajo futuro #  La ilusión de la pirámide es un llamativo efecto perceptivo relacionado con todos los fenómenos que implican inhibición lateral. Como se puedo observar, al generar varios cuadrados y conforme esta cantidad aumentaba el efecto visual de la aparición de una “X” en medio del escenario, adicionalmente, dicho efecto y su impresión en el observador podría cambiar dependiendo del color al que se dezplacen los cuadrados, blanco o negro, generando una sensación de realce o profundidad respectivamente. La explicación consiste en considerar las disposiciones de los campos receptivos de las células ganglionares antagónicas del centro-rededor que conviven con la imagen. Imaginemos una célula en una esquina con su centro en la mancha más clara, será inhibida por 1/4 de entorno de las manchas más claras y por 3/4 de las manchas más oscuras, así las células ganglionares de los bordes señalan más luminosidad. La percepción se integra con la información de las células ganglionares y se elimina la fuerte distorsión de la luminancia.\n"},{"id":7,"href":"/showcase/docs/shortcodes/Taller-2/","title":"Taller 2","section":"Shortcodes","content":"Taller 2 #  Esto fue el trabajo realizado para la segunda entrega de computación visual.\n"},{"id":8,"href":"/showcase/docs/shortcodes/Taller-2/antialiasing/","title":"Antialiasing","section":"Taller 2","content":"Anti-Aliasing #  Planteamiento del problema #  Considere un triángulo renderizado, si nos acercamos lo suficiente sobre la imagen del mismo, notaremos que los bordes del triángulo no son regulares, en cambio tiene un patrón de “escalera”, de “sierra” o de “tablero de ajedrez”. Dichos bordes que son observados, son llamados “jaggies” o bordes escalonados, y son el resultado de lo que en realidad está sucediendo, que no es más que la figura, en este caso el triángulo, se encuentra dividida en píxeles. En el proceso de rasterización lo que se realiza es descomponer una superficie continua, el triángulo, en elementos discretos, los píxeles. A este efecto en computación gráfica, se le conoce con el nombre de aliasing, que de forma rápida se puede ver como “el escalonamiento visual de los bordes que se produce en una imagen cuando la resolución es demasiado baja”. Siendo más precisos en su definición, el aliasing es el defecto gráfico característico que hace que en una pantalla ciertas curvas y líneas inclinadas presenten un efecto visual tipo “sierra” o “escalón”, dicho defecto se presenta cuando se intenta representar una imagen con curvas y líneas inclinadas en una pantalla, framebuffer o imagen, pero que debido a la resolución finita de la misma resulta que este sea incapaz de representar la curva como es, y por tanto dichas curvas se muestran en pantalla dentadas al estar compuestas por los píxeles.\nAntecedentes #  En consecuencia, para abordar los problemas generados por el aliasing, en computación visual se han desarrollado a lo largo de varias décadas algoritmos que buscan disminuir el impacto que tiene este defecto en el aspecto visual de los gráficos, entre los que resaltan nombres como el de Herbert Freeman en 1974 con \u0026ldquo;Computer processing of line drawing images\u0026rdquo;, o Edwin Catmull con trabajos como “A Subdivision Algorithm for Computer Display of Curved Surfaces” o \u0026ldquo;A hidden-surface algorithm with anti-aliasing\u0026rdquo; en los años 1974 y 1978 respectivamente. Dichos algoritmos se han determinado como algoritmos de anti-aliasing, o también conocido simplemente como AA, cuya definición más básica sería la de buscar “el suavizado de los bordes irregulares en las imágenes digitales promediando los colores de los píxeles en las fronteras”.\nFigura [1]. La letra de la izquierda sufre de aliasing. A la letra de la derecha se le ha aplicado anti-aliasing para que los bordes parezcan más suaves.\nEn cambio de renderizar con una única muestra por píxel, se divide el píxel en sub-píxeles, lo que conforme a mayor cantidad de los mismos, permite ilustrar los bordes de los objetos con mayor precisión. En la actualidad existen distintos métodos para tratar el problema del aliasing, Using high-resolution display, Post filtering (Supersampling), Pre-filtering (Area Sampling), Pixel phasing.\nHacer uso de dispositivos con mayor resolución - Una de las soluciones que se presentan para reducir el efecto visual causado por el aliasing es utilizar pantallas o dispositivos que sean de alta definición, con esto los “jaggies” o “bordes dentados” serán conforme mayor resolución cada vez más indistinguibles para el ojo humano, con lo cual estos bordes se tornan difusos y comenzarán a parecer más lisos.\nPre-filtración, Muestreo de área - En el muestreo de área, la intensidad de los píxeles es determinada calculando las áreas superpuestas de cada píxel con los objetos que van a ser desplegados, considerando los píxeles como áreas. Este método es conocido como pre-filtración ya que es un procedimiento que se hace antes de generar la imagen rasterizada.\nFases de pixel - El método se basa en desplazar la posición de los píxeles a posiciones aproximadas a la geometría del objeto. Algunos sistemas permiten que se ajuste el tamaño de los píxeles individuales para distribuir las intensidades, lo que es útil en la fase de píxeles.\nPost-filtración, Sobremuestreo - Los objetos son muestreados con una resolución superior y son desplegados con una resolución menor. En este método se incrementa la resolución de muestreo suponiendo que la pantalla estuviera compuesta de una cuadrícula más delgada de lo que realmente es. Para el cálculo de la intensidad de los píxeles se realiza al combinar o promediar los valores de las intensidades de los subpixeles que lo componen. Este método es conocido como post-filtración debido a que el procedimiento es realizado después de generar la imagen rasterizada. Un estilo mejorado de AA es el MSAA (antialiasing multimuestreo), que es un método más rápido y aproximado de supermuestreo AA, que tiene un menor costo computacional. Actualmente, las grandes empresas de tarjetas gráficas como CSAA de NVIDIA y CFAA de AMD desarrollan técnicas de sobremuestreo mejores y más sofisticadas, con el objetivo de resaltar en el mercado y mejorar el rendimiento de sus hardwares.\nCódigo (solución) y resultados #  Código en p5.js function AA(quadrilleF, points, row0, col0, row1, col1, row2, col2, shader, pattern0, pattern1 = pattern0, pattern2 = pattern0) {  if (Array.isArray(pattern0) \u0026amp;\u0026amp; Array.isArray(pattern1) \u0026amp;\u0026amp; Array.isArray(pattern2)) {  for (let i = 0; i \u0026lt; this.height; i++) {  for (let j = 0; j \u0026lt; this.width; j++) {  let numberPoints = 0;  for (let k = 0; k \u0026lt; points; k++) {  for (let h = 0; h \u0026lt; points; h++) {  let coords = quadrilleF._barycentric_coords(i + 0.01 + k*(0.98)/(points-1), j + 0.01 + h*(0.98)/(points-1), row0, col0, row1, col1, row2, col2);  if (coords.w0 \u0026gt;= 0 \u0026amp;\u0026amp; coords.w1 \u0026gt;= 0 \u0026amp;\u0026amp; coords.w2 \u0026gt;= 0) {  numberPoints++;  }  }  }  if (numberPoints \u0026gt; 0) {  let coords = this._barycentric_coords(i, j, row0, col0, row1, col1, row2, col2);  let length = Math.max(pattern0.length, pattern1.length, pattern2.length);  let _pattern = new Array(length);  for (let k = 0; k \u0026lt; _pattern.length; k++) {  _pattern[k] = (pattern0[k] ?? 0) * coords.w0 + (pattern1[k] ?? 0) * coords.w1 + (pattern2[k] ?? 0) * coords.w2;  }  for (let k = 0; k \u0026lt; _pattern.length; k++) {  _pattern[k] = 255 - (255 - _pattern[k])/(points*points)*numberPoints;  }  quadrilleF._memory2D[i][j] = shader({ pattern: _pattern, row: i, col: j });  }  }  }  }  }    Para generar un triángulo con Anti-aliasing presione la tecla \u0026ldquo;r\u0026rdquo;\n      const ROWS = 100; const COLS = 100; let numberPoints = 2; let quadrilleAA, quadrille, length; let color0 = [255,0,0], color1 = [0,255,0], color2 = [0,0,255]; let row0, col0, row1, col1, row2, col2; function setup() { createCanvas(500, 800); quadrilleAA = createQuadrille(ROWS, COLS); quadrille = createQuadrille(ROWS, COLS); length = 400/ROWS; colorPicker0 = createColorPicker(\u0026#39;red\u0026#39;); colorPicker0.position(420, 20); colorPicker1 = createColorPicker(\u0026#39;green\u0026#39;); colorPicker1.position(420, 70); colorPicker2 = createColorPicker(\u0026#39;blue\u0026#39;); colorPicker2.position(420, 120); colorPicker0.changed(changeColor); colorPicker1.changed(changeColor); colorPicker2.changed(changeColor); inp = createInput(\u0026#39;\u0026#39;); inp.position(420, 200); inp.size(50); inp.input(myInputEvent); } function myInputEvent() { numberPoints = this.value(); } function changeColor(){ color0 = colorPicker0.color().levels.slice(0, 3); color1 = colorPicker1.color().levels.slice(0, 3); color2 = colorPicker2.color().levels.slice(0, 3); } function draw() { background(\u0026#39;white\u0026#39;); textSize(15); text(\u0026#39;Puntos:\u0026#39;, 420, 190); drawQuadrille(quadrilleAA, { cellLength: length, outline: \u0026#39;black\u0026#39;, outlineWeight:0.001, board: false }); drawQuadrille(quadrille, { cellLength: length, outline: \u0026#39;black\u0026#39;, outlineWeight:0.001, board: false , pixelY: 400}); line(0,400,400,400); line(400,0,400,800); } function keyPressed() { randomize(); quadrilleAA.clear(); quadrille.clear(); if (key === \u0026#39;r\u0026#39;) { AA(quadrilleAA, numberPoints, row0, col0, row1, col1, row2, col2, colorize_shaderAA, color0, color1, color2); quadrille.rasterizeTriangle(row0, col0, row1, col1, row2, col2, colorize_shaderAA, color0, color1, color2); } } function colorize_shaderAA({ pattern: mixin }) { let rgb = mixin.slice(0, 3); return color(rgb); } function randomize() { col0 = int(random(0, COLS)); row0 = int(random(0, ROWS)); col1 = int(random(0, COLS)); row1 = int(random(0, ROWS)); col2 = int(random(0, COLS)); row2 = int(random(0, ROWS)); } function AA(quadrilleF, points, row0, col0, row1, col1, row2, col2, shader, pattern0, pattern1 = pattern0, pattern2 = pattern0) { if (Array.isArray(pattern0) \u0026amp;\u0026amp; Array.isArray(pattern1) \u0026amp;\u0026amp; Array.isArray(pattern2)) { for (let i = 0; i \u0026lt; this.height; i\u0026#43;\u0026#43;) { for (let j = 0; j \u0026lt; this.width; j\u0026#43;\u0026#43;) { let numberPoints = 0; for (let k = 0; k \u0026lt; points; k\u0026#43;\u0026#43;) { for (let h = 0; h \u0026lt; points; h\u0026#43;\u0026#43;) { let coords = quadrilleF._barycentric_coords(i \u0026#43; 0.01 \u0026#43; k*(0.98)/(points-1), j \u0026#43; 0.01 \u0026#43; h*(0.98)/(points-1), row0, col0, row1, col1, row2, col2); if (coords.w0 \u0026gt;= 0 \u0026amp;\u0026amp; coords.w1 \u0026gt;= 0 \u0026amp;\u0026amp; coords.w2 \u0026gt;= 0) { numberPoints\u0026#43;\u0026#43;; } } } if (numberPoints \u0026gt; 0) { let coords = this._barycentric_coords(i, j, row0, col0, row1, col1, row2, col2); let length = Math.max(pattern0.length, pattern1.length, pattern2.length); let _pattern = new Array(length); for (let k = 0; k \u0026lt; _pattern.length; k\u0026#43;\u0026#43;) { _pattern[k] = (pattern0[k] ?? 0) * coords.w0 \u0026#43; (pattern1[k] ?? 0) * coords.w1 \u0026#43; (pattern2[k] ?? 0) * coords.w2; } for (let k = 0; k \u0026lt; _pattern.length; k\u0026#43;\u0026#43;) { _pattern[k] = 255 - (255 - _pattern[k])/(points*points)*numberPoints; } quadrilleF._memory2D[i][j] = shader({ pattern: _pattern, row: i, col: j }); } } } } } function _barycentric_coords(row, col, row0, col0, row1, col1, row2, col2) { let edges = this._edge_functions(row, col, row0, col0, row1, col1, row2, col2); let area = this._parallelogram_area(row0, col0, row1, col1, row2, col2); return { w0: edges.e12 / area, w1: edges.e20 / area, w2: edges.e01 / area }; } function _parallelogram_area(row0, col0, row1, col1, row2, col2) { return (col1 - col0) * (row2 - row0) - (col2 - col0) * (row1 - row0); } function _edge_functions(row, col, row0, col0, row1, col1, row2, col2) { let e01 = (row0 - row1) * col \u0026#43; (col1 - col0) * row \u0026#43; (col0 * row1 - row0 * col1); let e12 = (row1 - row2) * col \u0026#43; (col2 - col1) * row \u0026#43; (col1 * row2 - row1 * col2); let e20 = (row2 - row0) * col \u0026#43; (col0 - col2) * row \u0026#43; (col2 * row0 - row2 * col0); return { e01, e12, e20 }; }      \"  Para la realización de este ejercicio de Anti-aliasing nos basamos en el método de Supersample Anti-aliasing (SSAA), mediante el cual por cada pixel existente dentro de la grilla original generamos una subgrilla virtual (la cantidad de filas y columnas de esta puede ser modificada por el usuario) dentro de cada uno de estos y mediante el uso de las coordenadas baricéntricas determinamos cual es la cantidad de subpíxeles dentro de cada pixel que se encuentra a su vez dentro de las coordenadas del triángulo, valga la pena recalcar que entre mayor sea el tamaño de la subgrilla virtual mayor cantidad de subpíxeles van a existir y el muestreo será más exacto y por lo tanto se tendrán resultados visuales más refinados y sutiles para el ojo humano. A partir de la cantidad de subpixeles que se encuentren dentro del triangulo podemos tomar la decisión sobre cual es la influencia que tiene este pixel dentro de nuestro muestreo de color, de esa manera asignarle el tono correspondiente, siendo los pixeles que menos puntos tienen dentro del triángulo los que poseen un color más tenue o cercano al blanco. De la misma manera se implementó gracias al uso de las coordenadas baricéntricas un sombreado del triángulo, donde cada una de sus vértices tiene un color (que puede ser escogido por el usuario en la animación) y a partir de estas se calcula el color de cada uno de los puntos coincidentes en la construcción del triángulo.\nConclusiones y trabajo futuro #  Es importante resaltar la relevancia que tienen las coordenadas baricéntricas y sus potenciales usos en el área de computación gráfica. Como pudimos observar durante la experimentación y la investigación acerca del tema, las coordenadas fueron una herramienta vital para la construcción de nuestro ejemplo, permitiendo submuestrear cada pixel basados en la idea identificar gracias a los valores arrojados por las coordenadas si el subpixel estaba en el interior o no del triángulo. Durante las búsquedas que se realizaron sobre el tema se encontró que actualmente el anti-aliasing es un tema de relevancia y más en el campo de los videojuegos, debido a los agradables efectos que genera en los gráficos y cómo logra mejorar la calidad estética de lo que diariamente observamos a través de las pantallas. Pensando en futuro, se sugiere trabajar sobre las ideas que actualmente ya se han desarrollado, en especial sobre los algoritmos basados en MSAA, y observando sus costos computacionales con respecto a su antecesor el SSAA.\n"},{"id":9,"href":"/showcase/docs/shortcodes/Taller-2/espacios/","title":"Espacios","section":"Taller 2","content":"Espacios #  Planteamiento del problema #  Antecedentes #  Código (solución) y resultados #  Código en p5.js function initPressure() {  Pressure.set(\u0026#39;#uiCanvas\u0026#39;, {  end: function(){  pressure = 0;  },  change: function(force, event) {  pressure = force;  }  });   Pressure.config({  polyfill: true,  polyfillSpeedUp: 1000,  polyfillSpeedDown: 300,  preventSelect: true,  only: null  }); }            // Brush controls let color; let brush; let easycam; let state; let drawState; let escorzo; let points; let record; var pressure = -2; let size = 1; function setup() { canvas = createCanvas(600, 450, WEBGL); canvas.id(\u0026#34;uiCanvas\u0026#34;); // easycam stuff let state = { distance: 250, // scalar center: [0, 0, 0], // vector rotation: [0, 0, 0, 1], // quaternion }; easycam = createEasyCam(); easycam.state_reset = state; // state to use on reset (double-click/tap) easycam.setState(state, 1000); // now animate to that state escorzo = true; perspective(); // brush stuff points = []; color = createColorPicker(\u0026#39;#ed225d\u0026#39;); color.position(width - 70, 40); sel = createRadio(); sel.option(\u0026#39;1\u0026#39;, \u0026#39;Esfera\u0026#39;); sel.option(\u0026#39;2\u0026#39;, \u0026#39;Cubo\u0026#39;); sel.option(\u0026#39;3\u0026#39;, \u0026#39;Cono\u0026#39;); sel.option(\u0026#39;4\u0026#39;, \u0026#39;Toroide\u0026#39;); sel.option(\u0026#39;5\u0026#39;, \u0026#39;Cilindro\u0026#39;); sel.position(width - 80, 100); sel.selected(\u0026#39;1\u0026#39;); sel.style(\u0026#39;width\u0026#39;, \u0026#39;75px\u0026#39;); // select initial brush brush = Brush; initPressure(); } function draw() { update(); background(120); push(); strokeWeight(0.8); stroke(\u0026#39;magenta\u0026#39;); grid({ dotted: false }); pop(); axes(); for (const point of points) { push(); translate(point.worldPosition); brush(point); pop(); } } function update() { let dx = abs(mouseX - pmouseX); let dy = abs(mouseY - pmouseY); speed = constrain((dx \u0026#43; dy) / (2 * (width - height)), 0, 1); if (record) { points.push({ worldPosition: treeLocation([mouseX, mouseY,pressure], { from: \u0026#39;SCREEN\u0026#39;, to: \u0026#39;WORLD\u0026#39; }), color: color.color(), speed: speed, size: size, shape: sel.value() }); } } function Brush(point) { push(); noStroke(); fill(point.color); if(point.shape==\u0026#34;1\u0026#34;){ sphere(point.size); }else if(point.shape==\u0026#34;2\u0026#34;){ box(point.size); }else if(point.shape==\u0026#34;3\u0026#34;){ cone(point.size,point.size); }else if(point.shape==\u0026#34;4\u0026#34;){ torus(point.size\u0026#43;1,point.size); }else{ cylinder(point.size,point.size); } pop(); } function keyPressed() { if (key === \u0026#39;r\u0026#39;) { record = !record; if(record){ easycam.removeMouseListeners(); }else{ easycam.attachMouseListeners(); } } if (key === \u0026#39;p\u0026#39;) { escorzo = !escorzo; escorzo ? perspective() : ortho(); } if (key == \u0026#39;c\u0026#39;) { points = []; } if (key == \u0026#39;a\u0026#39;) { size\u0026#43;\u0026#43;; } if (key == \u0026#39;m\u0026#39;) { size--; } } function mouseWheel(event) { //comment to enable page scrolling return false; } function initPressure() { Pressure.set(\u0026#39;#uiCanvas\u0026#39;, { end: function(){ pressure = 0; }, change: function(force, event) { pressure = force; } }); Pressure.config({ polyfill: true, polyfillSpeedUp: 1000, polyfillSpeedDown: 300, preventSelect: true, only: null }); }      \"  Conclusiones y trabajo futuro #  "}]