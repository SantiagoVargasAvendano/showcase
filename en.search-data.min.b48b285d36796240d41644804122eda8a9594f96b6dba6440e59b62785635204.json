[{"id":0,"href":"/showcase/docs/shortcodes/ebbinghaus/","title":"Ebbinghaus","section":"Shortcodes","content":"Ilusión dinámica de Ebbinghaus #  Planteamiento del problema #  Dentro del sitio web de Michael Bach se encontró una ilusión óptica que es la versión dinámica de \u0026ldquo;La ilusión de Ebbinghaus\u0026rdquo;. La ilusión consta de un anillo de discos azules y en su centro un disco naranja y todo se mueve, los discos azules cambian de tamaño pero el disco naranja permanece siempre con un tamaño constante, sin embargo, cuando los discos azules alcanzan el mayor tamaño el disco naranja parece haber disminuido de tamaño y de igual manera cuando los discos azules alcanzan su menor tamaño el disco naranja parece haber aumentado su tamaño.\nAntecedentes #  Esta ilusión corresponde a una variación dinámica de la ilusión de Ebbinghaus, variación creada por Christopher D. Blair, Gideon P. Caplovitz y Ryan E.B. Mruczek, que logró potenciar la fuerza de la ilusión y fue ganadora en el \u0026ldquo;Visual Illusion Contest\u0026rdquo; de 2014. En la ilusión de Ebbinghaus, se ven dos anillos de discos azules uno con los discos grandes y otro con los discos pequeños, en el centro de ambos anillos hay dos discos naranjas que a pesar de que no lo parezcan tienen igual tamaño; la ilusión lleva el nombre de Hermann Ebbinghaus, un pionero en la investigación de la memoria, que probablemente descubrió esta ilusión en la década de 1890, pero no la divulgó en ninguna publicación específica. Más adelante, Titchener (sin reclamar su autoría) la publicó en un libro de texto de 1901; por ello, también se le suele conocer como la ilusión de Titchener.\nCódigo (solución) y resultados #  Código en p5.js let x = 400,y = 400, L = 22, A, H, rad, distance, aux = 1;  function setup() {  createCanvas(500, 500);  frameRate(40);   A = cos(PI/3)*L;  H = sin(PI/3)*L; }  function draw() {  background(191);  if((frameCount-1) % 125 == 0){  aux = -aux;  }  x = x + aux * 1.25;  y = y + aux * 1.25;  noStroke();  fill(235, 131, 26);  ellipse(x,y,30);  fill(80, 125, 230);   rad = 12*pow((400/x),5);  distance = pow((400/x),4)   ellipse(x-L*distance,y,rad);  ellipse(x+L*distance,y,rad);   ellipse(x+A*distance,y-H*distance,rad);  ellipse(x-A*distance,y-H*distance,rad);   ellipse(x+A*distance,y+H*distance,rad);  ellipse(x-A*distance,y+H*distance,rad);   strokeWeight(5);  stroke(230, 216, 32);  point(x,y);  stroke(0, 60, 138);  point(x-A*distance,y-H*distance); }         let x = 400,y = 400, L = 22, A, H, rad, distance, aux = 1; function setup() { createCanvas(500, 500); frameRate(40); A = cos(PI/3)*L; H = sin(PI/3)*L; } function draw() { background(191); if((frameCount-1) % 125 == 0){ aux = -aux; } x = x \u0026#43; aux * 1.25; y = y \u0026#43; aux * 1.25; noStroke(); fill(235, 131, 26); ellipse(x,y,30); fill(80, 125, 230); rad = 12*pow((400/x),5); distance = pow((400/x),4) ellipse(x-L*distance,y,rad); ellipse(x\u0026#43;L*distance,y,rad); ellipse(x\u0026#43;A*distance,y-H*distance,rad); ellipse(x-A*distance,y-H*distance,rad); ellipse(x\u0026#43;A*distance,y\u0026#43;H*distance,rad); ellipse(x-A*distance,y\u0026#43;H*distance,rad); strokeWeight(5); stroke(230, 216, 32); point(x,y); stroke(0, 60, 138); point(x-A*distance,y-H*distance); }      \"  Conclusiones y trabajo futuro #  Basados en los resultados y en un proceso de observación, se concluye que existe una tendencia a aumentar el fenómeno visual generado cuando la visión del observador se fija en la circunferencia interior plasmada dentro del disco azul superior izquierdo. La ilusión de Ebbinghaus ha desempeñado un papel crucial en el debate sobre la existencia de vías separadas en el cerebro para la visión de percepción y visión de la acción. Se ha argumentado que la ilusión de Ebbinghaus distorsiona la percepción del tamaño, pero no para la acción. Así mismo se encontró un estudio en el cual muestran que existen 70 variantes genéticas relacionadas con la percepción de la ilusión de Ebbinghaus. Uno de los distintos campos en los que se puede seguir trabajando con la ilusión de Ebbinghaus es con la percepción de colores y si estos afectan de alguna manera la percepción del tamaño, también se puede considerar analizar si la forma en la que se está moviendo el sistema afecta que tanto se percibe la ilusión.\n"},{"id":1,"href":"/showcase/docs/shortcodes/estereoquinetico/","title":"Estereoquinetico","section":"Shortcodes","content":"Efecto estereoquinético #  Planteamiento del problema #  En la profundidad estereo cinética, el movimiento de rotación aumenta la impresión de profundidad que se observa en los patrones de anillos concéntricos. Normalmente, la rotación crea una impresión vívida de un cono que sobresale o un túnel que retrocede, o ambos.\nAntecedentes #  La primera vez que el término de profundidad estereoquinética fue descrito, fue en 1924 por Musatti CL en un informe científico (Sui fenomeni stereocineti) sobre la ilusión estereoquinética, atribuyendo el descubrimiento y el nombre a su maestro Vittorio Benussi. Este también fue usado cerca del año 1935 por el artista Marcel Duchamp, que llamaba \u0026ldquo;rotorrelieves\u0026rdquo; a sus discos giratorios.\nCódigo (solución) y resultados #  Código en p5.js let movement = 0, stop = 1, crater = 1; function setup() {  createCanvas(500, 500);  background(255);  frameRate(30);  noStroke();   buttonStop = createButton(\u0026#39;Parar\u0026#39;);  buttonStop.position(0, 478);  buttonStop.mousePressed(stop_move);   buttonReset = createButton(\u0026#39;Resetear\u0026#39;);  buttonReset.position(430, 0);  buttonReset.mousePressed(reset);   buttonInvert = createButton(\u0026#39;Crater\u0026#39;);  buttonInvert.position(447, 478);  buttonInvert.mousePressed(invert);  buttonInvert.style(\u0026#39;background-color\u0026#39;, color(255)); }  function invert() {  crater *= -1;  if(crater \u0026gt; 0){  buttonInvert.style(\u0026#39;background-color\u0026#39;, color(255));  }else{  buttonInvert.style(\u0026#39;background-color\u0026#39;, color(125));  } }  function reset() {  movement = 0;  stop = 1;  crater = 1;  buttonInvert.style(\u0026#39;background-color\u0026#39;, color(255)); }  function stop_move() {  stop *= -1; }  function draw() {  let aux = 2;  fill(0,0,255);  ellipse(250,250,500);  for (let i = 1; i \u0026lt; 12; i++) {  if(i % 2 == 0){  fill(0,0,255);  }else{  fill(255,255,0);  }  if(crater==1){  ellipse(250+(cos((movement % 360)*PI/180)*i*20),250+(sin((movement % 360)*PI/180)*i*20),500-i*40);  }else{  if(i \u0026lt; 7){  ellipse(250+(cos((movement % 360)*PI/180)*i*20),250+(sin((movement % 360)*PI/180)*i*20),500-i*40);  aux = i - 1;  }else{  ellipse(250+(cos((movement % 360)*PI/180)*aux*20),250+(sin((movement % 360)*PI/180)*aux*20),500-i*40);  aux -= 1;  }  }  }  if(stop == 1){  movement += 1;  }  }         let movement = 0, stop = 1, crater = 1; function setup() { createCanvas(500, 500); background(255); frameRate(30); noStroke(); buttonStop = createButton(\u0026#39;Parar\u0026#39;); buttonStop.position(0, 478); buttonStop.mousePressed(stop_move); buttonReset = createButton(\u0026#39;Resetear\u0026#39;); buttonReset.position(430, 0); buttonReset.mousePressed(reset); buttonInvert = createButton(\u0026#39;Crater\u0026#39;); buttonInvert.position(447, 478); buttonInvert.mousePressed(invert); buttonInvert.style(\u0026#39;background-color\u0026#39;, color(255)); } function invert() { crater *= -1; if(crater \u0026gt; 0){ buttonInvert.style(\u0026#39;background-color\u0026#39;, color(255)); }else{ buttonInvert.style(\u0026#39;background-color\u0026#39;, color(125)); } } function reset() { movement = 0; stop = 1; crater = 1; buttonInvert.style(\u0026#39;background-color\u0026#39;, color(255)); } function stop_move() { stop *= -1; } function draw() { let aux = 2; fill(0,0,255); ellipse(250,250,500); for (let i = 1; i \u0026lt; 12; i\u0026#43;\u0026#43;) { if(i % 2 == 0){ fill(0,0,255); }else{ fill(255,255,0); } if(crater==1){ ellipse(250\u0026#43;(cos((movement % 360)*PI/180)*i*20),250\u0026#43;(sin((movement % 360)*PI/180)*i*20),500-i*40); }else{ if(i \u0026lt; 7){ ellipse(250\u0026#43;(cos((movement % 360)*PI/180)*i*20),250\u0026#43;(sin((movement % 360)*PI/180)*i*20),500-i*40); aux = i - 1; }else{ ellipse(250\u0026#43;(cos((movement % 360)*PI/180)*aux*20),250\u0026#43;(sin((movement % 360)*PI/180)*aux*20),500-i*40); aux -= 1; } } } if(stop == 1){ movement \u0026#43;= 1; } }      \"  Manejo de la ilusión #  En la parte superior derecha se encuentra un botón de \u0026ldquo;Resetear\u0026rdquo; el cual devuelve la ilusión a su estado original que es sin cráter y la posición inicial; en la esquina inferior izquierda se encuentra el botón de \u0026ldquo;Parar\u0026rdquo; con el cual la ilusión interrumpe su rotación hasta que este sea pulsado de nuevo; por último en la esquina inferior derecha se encuentra un boton de \u0026ldquo;cráter\u0026rdquo; el cual sirve para generar dentro de la ilusión un efecto de profundidad.\nConclusiones y trabajo futuro #  Tomando en cuenta los resultados de la codificación y las pruebas visuales del mismo, se puede evidenciar cómo el movimiento de rotación en los círculos genera la impresión de profundidad. Como implementaciones a desarrollar para próximos intentos, se sugiere la idea de estudiar la combinación otro tipo de figuras y cómo eso cambia la dinámica de rotación, adicionalmente se sugiere que se tengan en cuenta los componente principales de la ilusión, tanto la rotación como la rapidez con la que se realiza, y sus relaciones o capacidades de potenciar las ilusiones propuestas.\n"},{"id":2,"href":"/showcase/docs/shortcodes/integrantes/","title":"Integrantes","section":"Shortcodes","content":"Integrantes #  Emmanuel Steven Rojas Arcila #   Perfil #  Estudiante de Sistemas y Computación cursando noveno semestre en la Universidad nacional de Colombia. Con intereses en las ramas de la criptografía y desarrollo de software con enfoques en el sector del frontend. Entre sus intereses fuera del área académica se encuentran realizar ejercicio y ver películas.   Santiago Vargas Avendaño #   Perfil #  Es un estudiante de ingeniería de sistemas y computación en noveno semestre, entre sus principales intereses académicos están la rama del desarrollo e ingeniería de software con especial enfoque en el backend. Los principales pasatiempos son el Voleibol, las manualidades (origami, tejido, bordado) y las series de televisión.   "},{"id":3,"href":"/showcase/docs/shortcodes/piramide/","title":"Piramide","section":"Shortcodes","content":"Ilusión de la pirámide #  Planteamiento del problema #  Se encontró dentro del archivo web del investigador Michael Bach sobre fenómenos visuales, una ilusión óptica denominada “ilusión de la pirámide” efecto perceptivo relacionado con todos los fenómenos que implican inhibición lateral.\nLa inhibición lateral se define como el proceso por el cual una célula inhibe la actividad de las células adyacentes. En las células de la retina, la inhibición lateral genera un realce de los bordes y un mayor contraste en las imágenes que se forman en el cerebro. El efecto de ésta inhibición lateral fue descubierto por Ernst Mach, que explicó en 1865 la ilusión visual denominada bandas de March. Este efecto produce que paneles que generan diferentes sombras colocados uno al lado del otro aparezcan más claros o más oscuros en las transiciones, a pesar del color uniforme dentro de un panel. Los paneles aparecen más claros en el borde con un panel más oscuro, y más oscuros en el borde con un panel más claro.\nEl propósito de la ilusión yace en generar la sensación de la existencia de una “X” dentro de cuadrados concéntricos en sus esquinas cuando realmente no existe. Para esto, se implementó un código que generase cuadrados concéntricos uno encima de otro, en el cual se va degradando ligeramente el color del cuadro siguiente, con lo cual, conforme mayor sea la cantidad de cuadros generados, la ilusión óptica empieza a hacer su aparición.\nAntecedentes #  Se tiene conocimiento de que fue demostrado por primera vez por Martinez-Conde \u0026amp; Macknik en la Reunión Soc Neurosci de 2001. Se ha incorporado a muchas pinturas Op Art como Arcturus II de Victor Vasarely.\nCódigo (solución) y resultados #  Código en p5.js let maxSixe = 500, h, maxMumberSquares = 50, squares = 1, color_val = \u0026#34;Azul\u0026#34;, invert_flag = 1; function setup() {  createCanvas(maxSixe+100, maxSixe);  background(255);  noStroke();  frameRate(20);   buttonUp = createButton(\u0026#39;⯅\u0026#39;);  buttonUp.position(560, 200);  buttonUp.mousePressed(changeUp);   buttonDown = createButton(\u0026#39;⯆\u0026#39;);  buttonDown.position(560, 220);  buttonDown.mousePressed(changeDown);   buttonReset = createButton(\u0026#39;Resetear\u0026#39;);  buttonReset.position(525, 100);  buttonReset.mousePressed(reset);   buttonInvert = createButton(\u0026#39;Invertir\u0026#39;);  buttonInvert.position(530, 400);  buttonInvert.mousePressed(invert);  buttonInvert.style(\u0026#39;background-color\u0026#39;, color(255));   color_sel = createSelect();  color_sel.position(530, 300);  color_sel.option(\u0026#39;Azul\u0026#39;);  color_sel.option(\u0026#39;Verde\u0026#39;);  color_sel.option(\u0026#39;Rojo\u0026#39;);  color_sel.selected(\u0026#39;Azul\u0026#39;);  color_sel.changed(mySelectEvent); }  function invert() {  invert_flag *= -1;  if(invert_flag \u0026gt; 0){  buttonInvert.style(\u0026#39;background-color\u0026#39;, color(255));  }else{  buttonInvert.style(\u0026#39;background-color\u0026#39;, color(125));  } }  function reset() {  squares = 1;  color_val = \u0026#34;Azul\u0026#34;;  color_sel.selected(\u0026#39;Azul\u0026#39;); }  function mySelectEvent() {  color_val = color_sel.value(); }  function changeUp() {  if(squares+1 \u0026lt; maxMumberSquares){  squares += 1;  } }  function changeDown() {  if(squares-1\u0026gt;0){  squares -= 1;  } }  function draw() {  fill(255);  rect(530,200,20,45)  textSize(15);  fill(0);  text(squares, 530,210,20,60);   if(squares \u0026lt; maxMumberSquares){  h = maxSixe/(2*squares);  for(let i = 0; i \u0026lt; squares; i++){  if(invert_flag \u0026gt; 0){  if(color_val == \u0026#34;Rojo\u0026#34;){  fill(255,0+i*(255/squares),0+i*(255/squares));  }else if(color_val == \u0026#34;Verde\u0026#34;){  fill(0+i*(255/squares),255,0+i*(255/squares));  }else{  fill(0+i*(255/squares),0+i*(255/squares),255);  }  }else{  if(color_val == \u0026#34;Rojo\u0026#34;){  fill(255-i*(255/squares),0,0);  }else if(color_val == \u0026#34;Verde\u0026#34;){  fill(0,255-i*(255/squares),0);  }else{  fill(0,0,255-i*(255/squares));  }  }  rect(0+i*h,0+i*h, 500-i*2*h);  }  } }         let maxSixe = 500, h, maxMumberSquares = 50, squares = 1, color_val = \u0026#34;Azul\u0026#34;, invert_flag = 1; function setup() { createCanvas(maxSixe\u0026#43;100, maxSixe); background(255); noStroke(); frameRate(20); buttonUp = createButton(\u0026#39;⯅\u0026#39;); buttonUp.position(560, 200); buttonUp.mousePressed(changeUp); buttonDown = createButton(\u0026#39;⯆\u0026#39;); buttonDown.position(560, 220); buttonDown.mousePressed(changeDown); buttonReset = createButton(\u0026#39;Resetear\u0026#39;); buttonReset.position(525, 100); buttonReset.mousePressed(reset); buttonInvert = createButton(\u0026#39;Invertir\u0026#39;); buttonInvert.position(530, 400); buttonInvert.mousePressed(invert); buttonInvert.style(\u0026#39;background-color\u0026#39;, color(255)); color_sel = createSelect(); color_sel.position(530, 300); color_sel.option(\u0026#39;Azul\u0026#39;); color_sel.option(\u0026#39;Verde\u0026#39;); color_sel.option(\u0026#39;Rojo\u0026#39;); color_sel.selected(\u0026#39;Azul\u0026#39;); color_sel.changed(mySelectEvent); } function invert() { invert_flag *= -1; if(invert_flag \u0026gt; 0){ buttonInvert.style(\u0026#39;background-color\u0026#39;, color(255)); }else{ buttonInvert.style(\u0026#39;background-color\u0026#39;, color(125)); } } function reset() { squares = 1; color_val = \u0026#34;Azul\u0026#34;; color_sel.selected(\u0026#39;Azul\u0026#39;); } function mySelectEvent() { color_val = color_sel.value(); } function changeUp() { if(squares\u0026#43;1 \u0026lt; maxMumberSquares){ squares \u0026#43;= 1; } } function changeDown() { if(squares-1\u0026gt;0){ squares -= 1; } } function draw() { fill(255); rect(530,200,20,45) textSize(15); fill(0); text(squares, 530,210,20,60); if(squares \u0026lt; maxMumberSquares){ h = maxSixe/(2*squares); for(let i = 0; i \u0026lt; squares; i\u0026#43;\u0026#43;){ if(invert_flag \u0026gt; 0){ if(color_val == \u0026#34;Rojo\u0026#34;){ fill(255,0\u0026#43;i*(255/squares),0\u0026#43;i*(255/squares)); }else if(color_val == \u0026#34;Verde\u0026#34;){ fill(0\u0026#43;i*(255/squares),255,0\u0026#43;i*(255/squares)); }else{ fill(0\u0026#43;i*(255/squares),0\u0026#43;i*(255/squares),255); } }else{ if(color_val == \u0026#34;Rojo\u0026#34;){ fill(255-i*(255/squares),0,0); }else if(color_val == \u0026#34;Verde\u0026#34;){ fill(0,255-i*(255/squares),0); }else{ fill(0,0,255-i*(255/squares)); } } rect(0\u0026#43;i*h,0\u0026#43;i*h, 500-i*2*h); } } }      \"  Manejo de la ilusión #  En la parte derecha de la ilusión se encuentran los controles para manejarla, el primero es un botón de \u0026ldquo;Resetearla\u0026rdquo; que lleva la ilusión a sus valores por defecto que es 1 cuadro y el color azul; seguido encontramos dos botones junto con un número a su lado el botón con la flecha hacia arriba aumenta la cantidad de cuadrados (hasta 50), el botón con la flecha hacia abajo disminuye la cantidad de cuadrados (hasta 1) y el número al lado de ellos muestra la cantidad actual de cuadrados; luego hayamos un menú desplegable en el cual podemos escoger cualquiera de los tres colores con los cuales se presenta la ilusión de la pirámide y por ultimo se encuentra un botón para “Invertir” la ilusión, es decir, que el degrade desde el color principal sea hacia blanco o hacia negro.\nConclusiones y trabajo futuro #  La ilusión de la pirámide es un llamativo efecto perceptivo relacionado con todos los fenómenos que implican inhibición lateral. Como se puedo observar, al generar varios cuadrados y conforme esta cantidad aumentaba el efecto visual de la aparición de una “X” en medio del escenario, adicionalmente, dicho efecto y su impresión en el observador podría cambiar dependiendo del color al que se dezplacen los cuadrados, blanco o negro, generando una sensación de realce o profundidad respectivamente. La explicación consiste en considerar las disposiciones de los campos receptivos de las células ganglionares antagónicas del centro-rededor que conviven con la imagen. Imaginemos una célula en una esquina con su centro en la mancha más clara, será inhibida por 1/4 de entorno de las manchas más claras y por 3/4 de las manchas más oscuras, así las células ganglionares de los bordes señalan más luminosidad. La percepción se integra con la información de las células ganglionares y se elimina la fuerte distorsión de la luminancia.\n"},{"id":4,"href":"/showcase/docs/shortcodes/referencias/","title":"Referencias","section":"Shortcodes","content":"Referencias #   Ilusión de la pirámide - Michael Bach Ilusión dinámica de Ebbinghaus - Michael Bach Efecto estereoquinético - Michael Bach Inhibición lateral Profundidad estereoquinética Ebbinghaus  "},{"id":5,"href":"/showcase/docs/shortcodes/registros/","title":"Registros","section":"Shortcodes","content":"Registros #  En está página se mantienen el registro de los encuentros\nPrimer taller #  29/marzo/2022 Primera entrega de propuesta hacia el profesor de 3 ilusiones visuales:\n Ilusión de la piramide Ilusión dinámica de Ebbinghaus Efecto estereoquinético también se planteó la idea de entregar un programa de \u0026ldquo;Todo es Om\u0026rdquo; pero por motivos de alcance de la entrega se concluyó que no era ideal.    31/marzo/2022 En esta sesión se presentó al profesor la ilusión dinámica de Ebbinghaus y la ilusión de la piramide, a lo cual se recibieron sus respectivas recomendaciones y sugerencias por parte del profesor, durante la clase se trabajó para poder determinar bien las coordenadas en las ilusiones.   "}]